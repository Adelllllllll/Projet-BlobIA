RÃ©sumÃ© pour README / Prompt de Reprise â€“ Projet Blob IA
1. Description du projet
Ce projet vise Ã  modÃ©liser le rÃ©seau de transports (mÃ©tro/RER) de lâ€™Ãle-de-France sous forme de graphe, et Ã  calculer/visualiser lâ€™affluence sur ce rÃ©seau de faÃ§on rÃ©aliste, dynamique (jour et heure) et modulaire.
Lâ€™objectifâ€¯: permettre des calculs de chemins optimisÃ©s selon divers critÃ¨res (rapiditÃ©, confort, affluenceâ€¦).

2. Partie â€œGRAPHEâ€
DonnÃ©es utilisÃ©esâ€¯:

Jeux de donnÃ©es Open Data surâ€¯: stations, correspondances, coordonnÃ©es GPS, affluences.

Alignement/normalisation des noms de stations (â€œstation_keyâ€ unique pour gÃ©rer synonymes et variantes).

Construction du grapheâ€¯:

Les nÅ“uds reprÃ©sentent chaque station/ligne (clÃ© = station_key + ligne).

Les arÃªtes sont :

Adjacence directe (poids = distance gÃ©odÃ©sique en mÃ¨tres, selon lâ€™ordre des stations sur chaque ligne)

â€œCorrespondance physiqueâ€â€¯: connecte toutes les variantes dâ€™une mÃªme station (pour simuler les correspondances, poids 0).

Graphe non orientÃ©, bidirectionnel.

Export/Visualisationâ€¯:

Fichiers CSVâ€¯: graph_nodes.csv, graph_edges.csv pour debug/analyse.

Graphe sauvegardÃ© en pickleâ€¯: graph_blobia.gpickle.

Visualisation matplotlib avec positionnement gÃ©ographique et couleur selon ligne ou attributs.

Scripts clÃ©sâ€¯:

build_graph.pyâ€¯: crÃ©ation du graphe Ã  partir des datasets alignÃ©s et export.

show_graph.py (optionnel)â€¯: visualisation rapide du graphe.

3. Partie â€œAFFLUENCEâ€
a) Calcul du score dâ€™affluence station/ligne
Butâ€¯: Attribuer un score rÃ©aliste dâ€™affluence Ã  chaque couple (station_key, ligne)â€¯:

Score dans [0.15, 1.0] (1â€¯=â€¯max affluence, 0.15â€¯=â€¯min).

MÃ©thodologieâ€¯:

Big hubs (gares majeures, places, correspondances)â€¯: scores fixes Ã©levÃ©s selon liste de hubs.

Bonus correspondanceâ€¯: stations avec plusieurs lignes ont un bonus (mÃªme hors hubs).

Propagation dÃ©gressive sur chaque ligneâ€¯: les scores des hubs/correspondances â€œse propagentâ€ (par multiplication, avec facteur de dÃ©croissance) aux stations voisines, dans les deux sens, jusquâ€™Ã  remplir tout le rÃ©seau.

Remplissage des trousâ€¯: si jamais un score nâ€™est pas attribuÃ©, on met le score min (sÃ©curitÃ©).

Scores par ligneâ€¯: certains hubs voient leur score ajustÃ© par la ligne (RER/mÃ©tro), paramÃ©trable.

Export CSVâ€¯: Stations_IDF_aligned_affluence.csv (une colonne â€œaffluence_scoreâ€ par station/ligne).

ParamÃ¨tres personnalisablesâ€¯:

Facteur de propagation, score min, bonus correspondance, scores hubs, scores par ligneâ€¯: tout est dans utils.py.

b) Modulation dynamique (jour/heure)
Profils dâ€™affluenceâ€¯: Dictionnaires Python dans utils.py, associant un coefficient Ã  chaque jour (PROFILE_JOUR) et chaque heure (PROFILE_HEURE) basÃ© sur la rÃ©alitÃ© du trafic francilien (heures de pointe, week-endâ€¦).

Score dynamique finalâ€¯:

Pour une station/ligne donnÃ©e, Ã  un jour/heure donnÃ©â€¯:

python
Copier
Modifier
affluence_dynamique = affluence_score * PROFILE_JOUR[jour] * PROFILE_HEURE[heure]
Application sur le grapheâ€¯: fonction dÃ©diÃ©e pour appliquer les scores dynamiques aux nÅ“uds du NetworkX Graph.

c) Architecture/fichiers principaux
affluence_builder/create_affluence.pyâ€¯: script dâ€™attribution et propagation des scores base (crÃ©ation du CSV).

affluence_builder/get_affluence.pyâ€¯: fonctions pour rÃ©cupÃ©rer le mapping dâ€™affluence dynamique (pour un jour/heure donnÃ©), et pour appliquer ce mapping Ã  un graphe.

affluence_builder/show_affluence.pyâ€¯: visualisation du graphe avec couleur des nÅ“uds selon lâ€™affluence dynamique pour un jour/heure.

4. Points clÃ©s pour future utilisation
Tout le systÃ¨me dâ€™affluence est MODULAIREâ€¯: tu peux changer la faÃ§on de calculer/propager ou ajouter de nouveaux profils sans impacter la structure du graphe.

Pour toute future fonction (calcul de chemin, dashboard, API, etc.)â€¯:

Utilise simplement la fonctionâ€¯:

python
Copier
Modifier
mapping = get_affluence_mapping_from_file("data/Stations_IDF_aligned_affluence.csv", "lundi", 8)
Ou, pour injection sur grapheâ€¯:

python
Copier
Modifier
apply_affluence_to_graph(G, mapping)
Les scores sont toujours accessibles dans les attributs des nÅ“uds sous le nom affluence_dynamique.

Visualisation simple pour dÃ©boguer ou illustrer le niveau dâ€™affluence en fonction du contexte.

Pour continuer le projet
Le graphe et lâ€™affluence dynamique sont prÃªts pour intÃ©grer un algorithme de calcul dâ€™itinÃ©raire (Dijkstra, A, etc.) tenant compte de lâ€™affluence.*

Il suffira dâ€™utiliser affluence_dynamique comme poids/cost supplÃ©mentaire dans les algos.

ğŸ“ Dossier blobia â€”Â Description, Organisation, Utilisation
Le dossier blobia regroupe toute la logique algorithmique et la gestion des donnÃ©es pour le planificateur de trajet MÃ©tro/RER Blob IA.

ğŸ—ï¸ Organisation des modules
blob_solver.py
ImplÃ©mente lâ€™algorithme principal ("blob solver") de recherche de trajets optimaux entre stations, en tenant compte :

du nombre dâ€™arrÃªts,

de lâ€™affluence,

du nombre de changements de ligne,

selon un curseur utilisateur rapiditÃ©/affluence.
Renvoie les meilleurs trajets ainsi quâ€™un score composite.

mapping.py
GÃ¨re :

la normalisation des noms (stations, lignes, monuments),

la correspondance entre monuments et stations proches (recherche gÃ©ographique),

des utilitaires pour lâ€™alignement des donnÃ©es (ex : nettoyer les accents, fusionner branches de lignes).

route.py
Coordonne lâ€™appel Ã  lâ€™algorithme Blob avec les bons paramÃ¨tres, et renvoie une version "human readable" des trajets pour lâ€™utilisateur ou le frontend.

show_route.py
Fournit des fonctions pour afficher de faÃ§on dÃ©taillÃ©e un trajet trouvÃ© par le blob solver (texte, Ã©tapes, changements, scoresâ€¦).

visu_routes.py
(Optionnel, visuel) : GÃ©nÃ¨re une visualisation graphique des trajets explorÃ©s et du rÃ©seau, pour debug ou pour des prÃ©sentations.

__init__.py
Rend le dossier importable comme module Python.

ğŸš¦ Comment Ã§a marche ?
EntrÃ©e utilisateur
Lâ€™utilisateur choisit :

une station ou un monument de dÃ©part,

une station ou un monument dâ€™arrivÃ©e,

le jour, lâ€™heure, et un curseur rapiditÃ© <-> affluence.

Recherche de stations
Les modules mapping.py trouvent la ou les stations les plus proches (si monument).

Appel Ã  lâ€™algo Blob
Le blob_solver cherche les chemins dans le graphe pondÃ©rÃ© (selon affluence, longueur, changements, etc.), optimisÃ©s selon le curseur.

Retour du meilleur trajet
FormatÃ© par route.py/show_route.py : sÃ©quence des stations, lignes, points de changement, mÃ©triques associÃ©es.

âš™ï¸ Utilisation (en ligne de commande ou import Python)
Lancer un calcul de trajet
Exemple dans main.py (ou dans un module externe) :

python
Copier
Modifier
from blobia.route import find_best_route

params = dict(
    depart="Chatelet",
    arrivee="Jardin de la Tour Eiffel",
    jour="lundi",
    heure=8,
    curseur=5,  # 1=Rapide, 10=Affluence faible
)

result = find_best_route(**params)
Afficher le trajet

python
Copier
Modifier
from blobia.show_route import print_route
print_route(result)
Utiliser en Streamlit
Les modules sont pensÃ©s pour Ãªtre rÃ©utilisÃ©s dans une interface web (Streamlit), il suffit dâ€™importer les fonctions et dâ€™appeler avec les paramÃ¨tres issus de lâ€™interface.

ğŸ“¦ Ã€ savoir sur les donnÃ©es
Les fichiers CSV de /data (stations, affluence, monuments, graph gpickle) sont nÃ©cessaires et doivent Ãªtre Ã  jour.

Le graphe (graph_blobia.gpickle) doit Ãªtre gÃ©nÃ©rÃ© au prÃ©alable via les scripts du projet (graph_pipeline.py).

ğŸ› ï¸ Debug, Visualisation avancÃ©e
Pour le debug ou la prÃ©sentation, visu_routes.py permet de visualiser tous les chemins explorÃ©s par lâ€™algo (besoin de matplotlib et networkx).

Les logs/DEBUG sâ€™activent en passant verbose=True dans certaines fonctions.

âœ¨ RÃ©sumÃ©
Le dossier blobia :

Centralise toute la logique "intelligente" de calcul de trajets.

Fournit des modules prÃªts Ã  lâ€™emploi, importables dans nâ€™importe quel script Python.

Permet une intÃ©gration facile dans un script CLI ou une interface web.

SÃ©pare les Ã©tapes de recherche, formatage et affichage pour une Ã©volutivitÃ© maximale.

